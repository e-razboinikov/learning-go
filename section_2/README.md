# Секция 2: Знакомство с языком Go

## Переменные и функции:
* Два вида объявления переменной: 

	```
	var myVar string - явная типизация
	```
	```
	myVar := "John" - неявная типизация
	```

* Функции могут возвращать несколько значений:

	```
	func saySomething(something string) (string, string) {
		return something, "World"
	}
	```

## Указатели

* Когда в функцию передается переменная, то создается её копия и работа внутри функции производится с копией переменной.
* Если необходимо производить работу с самой переменной, то для этого используются указатели.
* При вызове функции передается указатель на переменную с помощью * 
	```
	doSomething(*myVar)
	```
* Функция должна ожидать принятие указателя:

	```
	func changeUsingPointer(s *string) {
		*s = "Red"
	}
	```

## Типы данных

* Наиболеее часто используются: int, float64, bool, string
* У числовых типов есть подтипы (например, int8, float32) 
* [Ссылка на статью обо всех втроенных типых данных](https://metanit.com/go/tutorial/2.3.php)
* Есть возможность объявлять свои типы данных ключевым словом struct:
	```
	type User struct {
	FirstName   string
	LastName    string
	PhoneNumber string
	Age         int
	BirthDate   time.Time
	}
	```
* Если имя поля, переменной, функции начинаются с большой буквы, то они являются общедоступными, а если с маленькой - то приватными.	
* При помощи указателя * на тип [myStruct] можно расширять
	функционал типа путем добавления функций. Что-то вроде методов
	внутри класса:
	```
	func (m *myStruct) printFirstName() string {
	return m.FirstName
	}
	```

## Массивы и словари (Slices and Maps)
  * Slice - массив в языке Go. Можем объявляться как с явной, так и с неявной типизацией:
	```
	var mySlice []int - явная типизация

	mySlice := []int{1, 2, 3} - неявная типизация
	```
* Чтобы добавить элемент в массив используется метод append: 
	```
	mySlice = append(mySlice, 4, 5, 6)
	```
* Map - словарь ключ - значение (key - value), стандартная реализация. Способы объявления:
	```
	myMap := make(map[string]string)

	mySecondMap := make(map[string]interface{}) - тип value не задан, не рекомендуется использовать
	```

## Операторы ветвления (if-else, switch-case)

* В языке Go представлено два оператора ветвления: if-else и switch-case. Их реализация и функционал стандартны:
 
	```
	if isTrue {
		log.Println("true")
	} else {
		log.Println("false")
	}
	```

	```
	switch myInt {
	case 99:
		log.Println("99")
	case 100:
		log.Println("100")
	case 101:
		log.Println("101")
	default:
		log.Println("else")
	}
	```

## Циклы for и range

* В Go используется только один цикл - for:
	```
	for i := 0; i <= 10; i++ {
		log.Println(i * i)
	}
	```
* Так же есть вариция цикла for для итеррации по массивам и словарям - range: 
	```
	for i, x := range myMap {
		log.Println(i, x)
	}
	```

	```
	for i, x := range mySlice {
		log.Println(i, x.FirstName)
	}
	```

## Интерфейсы	

* В Go представлены интерфейсы. Это своего рода контракт на то, что структура данных, реализующая его, будет обладать определнным функционалом.
* Весь код с комментариями смотри [здесь](2.9_interfaces/main.go). 

## Пакеты

* Весь код в языке Go организуется в пакеты. Пакеты представляют удобную организацию разделения кода на отдельные части или модули. Модульность позволяет определять один раз пакет с нужной функциональностью и потом использовать его многкратно в различных программах.
* Код пакета располагается в одном или нескольких файлах с расширением go. Для определения пакета применяется ключевое слово package. Например:
	```
	package main

	import "fmt"
 
	func main() {
		
		fmt.Println("Hello Go")
	}
	```
* Для использования модульности нужно инициализировать пакет следующей командой:
  
	> go mod init github.com/e-razboinikov/learning-go/2.11_packages	

## Каналы

* Каналы (channels) представляют инструменты коммуникации между горутинами. Для определения канала применяется ключевое слово chan:
	```
	intChan := make(chan int)
	```	
* Хорошей практикой является закрытие канала после завершения работы программы: 

	```
	defer close(intChan)
	```	
* Для передачи данных в канал или, наоборот, из канала применяется операция <- (направленная влево стрелка). 

	```
	intCh <- 5 - передача данных в канал

	val := <- intCh - получение данных из канала в переменную
	```	

## Работа с JSON

* В Go очень легко и приятно работать с JSON-ами, весь код с комментариями [здесь.](/section_2/2.13_reading_and_writing_json/main.go)